# Gemini CLIコア: ツールAPI

Gemini CLIコア（`packages/core`）は、ツールの定義、登録、実行のための堅牢なシステムを備えています。これらのツールは、Geminiモデルの機能を拡張し、ローカル環境との対話、Webコンテンツの取得、単純なテキスト生成を超えたさまざまなアクションの実行を可能にします。

## コアコンセプト

- **ツール (`tools.ts`):** すべてのツールの契約を定義するインターフェイスと基本クラス（`BaseTool`）。各ツールには次のものが必要です。

  - `name`: 一意の内部名（GeminiへのAPI呼び出しで使用）。
  - `displayName`: ユーザーフレンドリーな名前。
  - `description`: ツールが何をするかを明確に説明したもので、Geminiモデルに提供されます。
  - `parameterSchema`: ツールが受け入れるパラメーターを定義するJSONスキーマ。これは、Geminiモデルがツールを正しく呼び出す方法を理解するために重要です。
  - `validateToolParams()`: 受信したパラメーターを検証するメソッド。
  - `getDescription()`: 実行前に特定のパラメーターでツールが何をするかを人間が読める形式で説明を提供するメソッド。
  - `shouldConfirmExecute()`: 実行前にユーザーの確認が必要かどうかを判断するメソッド（潜在的に破壊的な操作など）。
  - `execute()`: ツールのアクションを実行し、`ToolResult`を返すコアメソッド。

- **`ToolResult` (`tools.ts`):** ツールの実行結果の構造を定義するインターフェイス。

  - `llmContent`: コンテキストのためにLLMに返送される履歴に含める事実に基づく文字列コンテンツ。
  - `returnDisplay`: CLIに表示するためのユーザーフレンドリーな文字列（多くの場合Markdown）または特別なオブジェクト（`FileDiff`など）。

- **ツールレジストリ (`tool-registry.ts`):** 次の責任を負うクラス（`ToolRegistry`）。
  - **ツールの登録:** 利用可能なすべての組み込みツール（`ReadFileTool`、`ShellTool`など）のコレクションを保持します。
  - **ツールの検出:** ツールを動的に検出することもできます。
    - **コマンドベースの検出:** 設定で`toolDiscoveryCommand`が構成されている場合、このコマンドが実行されます。カスタムツールを記述したJSONを出力することが期待され、これらは`DiscoveredTool`インスタンスとして登録されます。
    - **MCPベースの検出:** `mcpServerCommand`が構成されている場合、レジストリはモデルコンテキストプロトコル（MCP）サーバーに接続して、ツールを一覧表示および登録できます（`DiscoveredMCPTool`）。
  - **スキーマの提供:** 登録されているすべてのツールの`FunctionDeclaration`スキーマをGeminiモデルに公開し、利用可能なツールとその使用方法をモデルが認識できるようにします。
  - **ツールの取得:** コアが実行のために名前で特定のツールを取得できるようにします。

## 組み込みツール

コアには、通常`packages/core/src/tools/`にある、事前定義されたツールスイートが付属しています。これらには次のものが含まれます。

- **ファイルシステムツール:**
  - `LSTool` (`ls.ts`): ディレクトリの内容を一覧表示します。
  - `ReadFileTool` (`read-file.ts`): 単一のファイルの内容を読み取ります。`absolute_path`パラメーターを受け取り、これは絶対パスである必要があります。
  - `WriteFileTool` (`write-file.ts`): ファイルにコンテンツを書き込みます。
  - `GrepTool` (`grep.ts`): ファイル内のパターンを検索します。
  - `GlobTool` (`glob.ts`): globパターンに一致するファイルを検索します。
  - `EditTool` (`edit.ts`): ファイルをインプレースで変更します（多くの場合、確認が必要です）。
  - `ReadManyFilesTool` (`read-many-files.ts`): 複数のファイルまたはglobパターンからコンテンツを読み取って連結します（CLIの`@`コマンドで使用）。
- **実行ツール:**
  - `ShellTool` (`shell.ts`): 任意のシェルコマンドを実行します（慎重なサンドボックス化とユーザーの確認が必要です）。
- **Webツール:**
  - `WebFetchTool` (`web-fetch.ts`): URLからコンテンツを取得します。
  - `WebSearchTool` (`web-search.ts`): Web検索を実行します。
- **メモリツール:**
  - `MemoryTool` (`memoryTool.ts`): AIのメモリと対話します。

これらの各ツールは`BaseTool`を拡張し、特定の機能に必要なメソッドを実装します。

## ツール実行フロー

1.  **モデルリクエスト:** Geminiモデルは、ユーザーのプロンプトと提供されたツールのスキーマに基づいて、ツールを使用することを決定し、応答に`FunctionCall`部分を返します。これには、ツール名と引数が指定されています。
2.  **コアがリクエストを受信:** コアはこの`FunctionCall`を解析します。
3.  **ツールの取得:** `ToolRegistry`で要求されたツールを検索します。
4.  **パラメーターの検証:** ツールの`validateToolParams()`メソッドが呼び出されます。
5.  **確認（必要な場合）:**
    - ツールの`shouldConfirmExecute()`メソッドが呼び出されます。
    - 確認の詳細が返された場合、コアはこれをCLIに伝え、CLIがユーザーにプロンプトを表示します。
    - ユーザーの決定（続行、キャンセルなど）がコアに返送されます。
6.  **実行:** 検証および確認された場合（または確認が不要な場合）、コアは提供された引数と`AbortSignal`（キャンセルされる可能性があるため）を使用してツールの`execute()`メソッドを呼び出します。
7.  **結果の処理:** `execute()`からの`ToolResult`がコアによって受信されます。
8.  **モデルへの応答:** `ToolResult`の`llmContent`は`FunctionResponse`としてパッケージ化され、ユーザー向けの応答を生成し続けることができるようにGeminiモデルに返送されます。
9.  **ユーザーへの表示:** `ToolResult`の`returnDisplay`は、ツールが何をしたかをユーザーに示すためにCLIに送信されます。

## カスタムツールによる拡張

一般的なエンドユーザー向けの提供されたファイルでは、ユーザーによる新しいツールの直接的なプログラムによる登録は主要なワークフローとして明示的に詳述されていませんが、アーキテクチャは次の方法による拡張をサポートしています。

- **コマンドベースの検出:** 上級ユーザーまたはプロジェクト管理者は、`settings.json`で`toolDiscoveryCommand`を定義できます。このコマンドは、Gemini CLIコアによって実行されると、`FunctionDeclaration`オブジェクトのJSON配列を出力する必要があります。コアはこれらを`DiscoveredTool`インスタンスとして利用できるようにします。対応する`toolCallCommand`は、これらのカスタムツールの実際の実行を担当します。
- **MCPサーバー:** より複雑なシナリオでは、1つ以上のMCPサーバーをセットアップし、`settings.json`の`mcpServers`設定を介して構成できます。Gemini CLIコアは、これらのサーバーによって公開されているツールを検出して使用できます。前述のように、複数のMCPサーバーがある場合、ツール名は構成のサーバー名でプレフィックスが付けられます（例：`serverAlias__actualToolName`）。

このツールシステムは、Geminiモデルの機能を強化するための柔軟で強力な方法を提供し、Gemini CLIを幅広いタスクに対応できる汎用性の高いアシスタントにします。 