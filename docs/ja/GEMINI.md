## ビルドと実行

変更を提出する前に、完全なプリフライトチェックを実行して検証することが重要です。このコマンドは、リポジトリをビルドし、すべてのテストを実行し、型エラーをチェックし、コードをリントします。

完全なチェックスイートを実行するには、以下のコマンドを実行してください：

```bash
npm run preflight
```

この単一のコマンドにより、変更がプロジェクトのすべての品質ゲートを満たすことが保証されます。個別のステップ（`build`、`test`、`typecheck`、`lint`）を別々に実行することもできますが、包括的な検証を確実にするために`npm run preflight`を使用することを強く推奨します。

## テストの記述

このプロジェクトは**Vitest**を主要なテストフレームワークとして使用しています。テストを記述する際は、既存のパターンに従うことを目指してください。主要な規約は以下の通りです：

### テスト構造とフレームワーク

- **フレームワーク**: すべてのテストはVitest（`describe`、`it`、`expect`、`vi`）を使用して記述されます。
- **ファイルの場所**: テストファイル（ロジック用の`*.test.ts`、Reactコンポーネント用の`*.test.tsx`）は、テスト対象のソースファイルと同じ場所に配置されます。
- **設定**: テスト環境は`vitest.config.ts`ファイルで定義されます。
- **セットアップ/ティアダウン**: `beforeEach`と`afterEach`を使用します。一般的に、`beforeEach`で`vi.resetAllMocks()`が呼び出され、`afterEach`で`vi.restoreAllMocks()`が呼び出されます。

### モッキング（VitestのVi）

- **ESモジュール**: `vi.mock('module-name', async (importOriginal) => { ... })`でモックします。選択的なモッキングには`importOriginal`を使用します。
  - _例_: `vi.mock('os', async (importOriginal) => { const actual = await importOriginal(); return { ...actual, homedir: vi.fn() }; });`
- **モッキング順序**: モジュールレベルの定数に影響する重要な依存関係（例：`os`、`fs`）については、他のインポートの前に、テストファイルの_最上部_に`vi.mock`を配置します。
- **ホイスティング**: `vi.mock`ファクトリーでの使用前にモック関数を定義する必要がある場合は、`const myMock = vi.hoisted(() => vi.fn());`を使用します。
- **モック関数**: `vi.fn()`で作成します。`mockImplementation()`、`mockResolvedValue()`、または`mockRejectedValue()`で動作を定義します。
- **スパイ**: `vi.spyOn(object, 'methodName')`を使用します。`afterEach`で`mockRestore()`を使用してスパイを復元します。

### 一般的にモックされるモジュール

- **Node.js組み込みモジュール**: `fs`、`fs/promises`、`os`（特に`os.homedir()`）、`path`、`child_process`（`execSync`、`spawn`）。
- **外部SDK**: `@google/genai`、`@modelcontextprotocol/sdk`。
- **内部プロジェクトモジュール**: 他のプロジェクトパッケージからの依存関係は、しばしばモックされます。

### Reactコンポーネントテスト（CLI UI - Ink）

- `ink-testing-library`の`render()`を使用します。
- `lastFrame()`で出力をアサートします。
- 必要な`Context.Provider`でコンポーネントをラップします。
- `vi.mock()`を使用してカスタムReactフックと複雑な子コンポーネントをモックします。

### 非同期テスト

- `async/await`を使用します。
- タイマーについては、`vi.useFakeTimers()`、`vi.advanceTimersByTimeAsync()`、`vi.runAllTimersAsync()`を使用します。
- プロミスの拒否をテストするには、`await expect(promise).rejects.toThrow(...)`を使用します。

### 一般的なガイダンス

- テストを追加する際は、まず既存のテストを調べて、確立された規約を理解し、それに準拠してください。
- 既存のテストファイルの上部にあるモックに特に注意してください。これらは重要な依存関係と、テスト環境でそれらがどのように管理されているかを明らかにします。

## Gitリポジトリ

このプロジェクトのメインブランチは「main」と呼ばれます。

## JavaScript/TypeScript

このReact、Node、TypeScriptコードベースに貢献する際は、JavaScriptクラス構文よりも、TypeScriptインターフェースまたは型宣言を伴うプレーンJavaScriptオブジェクトの使用を優先してください。このアプローチは、特にReactとの相互運用性と全体的なコードの保守性に関して、大きな利点を提供します。

### クラスよりもプレーンオブジェクトを優先する

JavaScriptクラスは、その性質上、内部状態と動作をカプセル化するように設計されています。これはオブジェクト指向パラダイムにおいては有用ですが、Reactのコンポーネントベースアーキテクチャと組み合わせる際に、不要な複雑さと摩擦を導入することがよくあります。プレーンオブジェクトが優先される理由は以下の通りです：

- シームレスなReact統合: Reactコンポーネントは、明示的なpropsと状態管理で繁栄します。クラスがインスタンス内に直接内部状態を格納する傾向は、propsと状態の伝播を理解し、維持することを困難にする可能性があります。一方、プレーンオブジェクトは（慎重に使用される場合）本質的に不変であり、propsとして簡単に渡すことができ、データフローを簡素化し、予期しない副作用を減らします。

- 定型文の削減と簡潔性の向上: クラスは、コンストラクタ、thisバインディング、ゲッター、セッター、その他の定型文の使用を促進することが多く、コードを不必要に肥大化させる可能性があります。TypeScriptインターフェースと型宣言は、クラス定義の実行時オーバーヘッドや冗長性なしに、強力な静的型チェックを提供します。これにより、JavaScriptの関数型プログラミングの強みに合った、より簡潔で読みやすいコードが可能になります。

- 可読性と予測可能性の向上: プレーンオブジェクト、特にその構造がTypeScriptインターフェースで明確に定義されているものは、読みやすく理解しやすいことが多いです。それらのプロパティは直接アクセス可能で、隠された内部状態や複雑な継承チェーンをナビゲートする必要がありません。この予測可能性は、バグの減少とより保守しやすいコードベースにつながります。

- 不変性の簡素化: 厳密に強制されるわけではありませんが、プレーンオブジェクトはデータに対する不変なアプローチを促進します。オブジェクトを変更する必要がある場合、通常は元のオブジェクトを変更するのではなく、望ましい変更を加えた新しいオブジェクトを作成します。このパターンは、Reactの調整プロセスと完全に一致し、共有可変状態に関連する微妙なバグを防ぐのに役立ちます。

- より良いシリアライゼーションとデシリアライゼーション: プレーンJavaScriptオブジェクトは、JSONへのシリアライゼーションとその逆のデシリアライゼーションが自然に簡単で、これはWeb開発（例：API通信やローカルストレージ）における一般的な要件です。メソッドとプロトタイプを持つクラスは、このプロセスを複雑にする可能性があります。

### カプセル化のためのESモジュール構文の採用

冗長で時には柔軟性を制限するJavaのようなprivateまたはpublicクラスメンバーに依存するのではなく、privateとpublic APIをカプセル化するためにESモジュール構文（`import`/`export`）を活用することを強く推奨します。

- より明確なパブリックAPI定義: ESモジュールでは、エクスポートされるものはそのモジュールのパブリックAPIの一部であり、エクスポートされないものは本質的にそのモジュールのプライベートです。これにより、コードのどの部分が他のモジュールによって消費されることを意図しているかを定義する非常に明確で明示的な方法が提供されます。

- テスト可能性の向上（内部を公開することなく）: デフォルトでは、エクスポートされていない関数や変数はモジュールの外部からアクセスできません。これにより、内部実装の詳細ではなく、モジュールのパブリックAPIをテストすることが促進されます。テスト目的でエクスポートされていない関数をスパイまたはスタブする必要がある場合、それは「コードの匂い」であることが多く、その関数が明確に定義されたパブリックAPIを持つ独自の分離可能でテスト可能なモジュールに抽出される良い候補であることを示しています。これにより、より堅牢で保守しやすいテスト戦略が促進されます。

- 結合の削減: import/exportを通じて明示的に定義されたモジュール境界は、コードベースの異なる部分間の結合を削減するのに役立ちます。これにより、個々のコンポーネントを分離してリファクタリング、デバッグ、理解することが容易になります。

### `any`型と型アサーションの回避；`unknown`の優先

TypeScriptの力は、コードが実行される前に潜在的なエラーをキャッチする静的型チェック機能を提供することにあります。これを完全に活用するには、`any`型を避け、型アサーションを慎重に使用することが重要です。

- **`any`の危険性**: anyを使用すると、その特定の変数や式のTypeScriptの型チェックを効果的に無効にします。短期的には便利に見えるかもしれませんが、重大なリスクを導入します：

  - **型安全性の喪失**: 型チェックのすべての利点を失い、TypeScriptが本来キャッチしていたであろう実行時エラーを簡単に導入できるようになります。
  - **可読性と保守性の低下**: `any`型を持つコードは理解と保守が困難になります。データの期待される型が明示的に定義されなくなるためです。
  - **根本的な問題のマスキング**: しばしば、anyの必要性は、コードの設計や外部ライブラリとの相互作用方法におけるより深い問題を示しています。型を洗練するか、コードをリファクタリングする必要があることのサインです。

- **`any`よりも`unknown`を優先**: コンパイル時に値の型を絶対に決定できず、anyに手を伸ばしたくなる場合は、代わりに`unknown`の使用を検討してください。`unknown`は`any`の型安全な対応物です。`unknown`型の変数は任意の値を保持できますが、その上で任意の操作を実行する前に型の絞り込み（例：`typeof`や`instanceof`チェック、または型アサーション）を実行する必要があります。これにより、`unknown`型を明示的に処理することが強制され、偶発的な実行時エラーを防ぎます。

  ```
  function processValue(value: unknown) {
     if (typeof value === 'string') {
        // valueは今安全にstringです
        console.log(value.toUpperCase());
     } else if (typeof value === 'number') {
        // valueは今安全にnumberです
        console.log(value * 2);
     }
     // 絞り込みなしでは、'value'のプロパティやメソッドにアクセスできません
     // console.log(value.someProperty); // Error: Object is of type 'unknown'.
  }
  ```

- **型アサーション（`as Type`）- 注意して使用**: 型アサーションは、TypeScriptコンパイラに「私を信じて、これは確実にこの型です」と伝えます。正当な使用例（例：完璧な型定義を持たない外部ライブラリとの取り扱い、またはコンパイラよりも多くの情報を持っている場合）はありますが、控えめに、極度の注意を払って使用すべきです。
  - **型チェックのバイパス**: `any`と同様に、型アサーションはTypeScriptの安全チェックをバイパスします。アサーションが正しくない場合、TypeScriptが警告しない実行時エラーを導入します。
  - **テストにおけるコードの匂い**: `any`や型アサーションが魅力的に見える一般的なシナリオは、「プライベート」な実装詳細をテストしようとする場合（例：モジュール内のエクスポートされていない関数をスパイまたはスタブする）です。これは、テスト戦略と潜在的にコード構造における「コードの匂い」の強い兆候です。プライベートな内部へのアクセスを強制しようとする代わりに、それらの内部詳細が明確に定義されたパブリックAPIを持つ別のモジュールにリファクタリングされるべきかどうかを検討してください。これにより、カプセル化を損なうことなく、本質的にテスト可能になります。

### JavaScriptの配列演算子の採用

コードの清潔さをさらに向上させ、安全な関数型プログラミング実践を促進するために、JavaScriptの豊富な配列演算子セットを可能な限り活用してください。`.map()`、`.filter()`、`.reduce()`、`.slice()`、`.sort()`などのメソッドは、不変で宣言的な方法でデータコレクションを変換・操作するために非常に強力です。

これらの演算子を使用することで：

- 不変性の促進: ほとんどの配列演算子は新しい配列を返し、元の配列をそのまま残します。この関数型アプローチは、意図しない副作用を防ぎ、コードをより予測可能にします。
- 可読性の向上: 配列演算子をチェーンすることで、従来のforループや命令型ロジックよりも簡潔で表現力豊かなコードになることが多いです。操作の意図が一目で明確になります。
- 関数型プログラミングの促進: これらの演算子は関数型プログラミングの基礎であり、副作用を引き起こすことなく入力を受け取り出力を生成する純粋関数の作成を促進します。このパラダイムは、Reactとよく連携する堅牢でテスト可能なコードを書くために非常に有益です。

これらの原則を一貫して適用することで、効率的で高性能であるだけでなく、現在も将来も作業するのが楽しいコードベースを維持できます。

## React（[react-mcp-server](https://github.com/facebook/react/blob/4448b18760d867f9e009e810571e7a3b8930bb19/compiler/packages/react-mcp-server/src/index.ts#L376C1-L441C94)からミラーリングし調整）

### 役割

あなたは、ユーザーがより効率的で最適化可能なReactコードを書くのを支援するReactアシスタントです。React Compilerが自動的に最適化を適用できるパターンを特定することを専門とし、不要な再レンダリングを削減し、アプリケーションのパフォーマンスを向上させます。

### 作成・提案するすべてのコードでこれらのガイドラインに従ってください

フックを使用した関数コンポーネントを使用: クラスコンポーネントや古いライフサイクルメソッドを生成しないでください。状態は`useState`または`useReducer`で管理し、副作用は`useEffect`（または関連するフック）で管理してください。新しいコンポーネントロジックには常に関数とフックを優先してください。

レンダリング中にコンポーネントを純粋で副作用のないものに保つ: コンポーネントの関数本体内で直接副作用（サブスクリプション、ネットワークリクエスト、外部変数の変更など）を実行するコードを作成しないでください。そのようなアクションは`useEffect`でラップするか、イベントハンドラーで実行する必要があります。レンダリングロジックがpropsと状態の純粋関数であることを確認してください。

一方向データフローを尊重: propsを通じてデータを下に渡し、グローバルな変更を避けてください。2つのコンポーネントがデータを共有する必要がある場合は、その状態を共通の親に持ち上げるか、React Contextを使用してください。ローカル状態を同期したり外部変数を使用したりしようとしないでください。

状態を直接変更しない: 常に状態を不変に更新するコードを生成してください。例えば、状態を更新する際はスプレッド構文や他の方法を使用して新しいオブジェクト/配列を作成してください。状態変数に対して`state.someValue = ...`のような代入や`array.push()`のような配列変更を使用しないでください。状態を更新するには状態セッター（`useState`からの`setState`など）を使用してください。

`useEffect`と他のエフェクトフックを正確に使用: `useEffect`を使えると思う時はいつでも、それを避けるためにもっと深く考え、推論してください。`useEffect`は主に同期のためにのみ使用されます。例えば、Reactを何らかの外部状態と同期させるためです。重要 - `useEffect`内で`setState`（`useState`から返される2番目の値）を使用しないでください。パフォーマンスが低下します。エフェクトを書く際は、依存関係配列に必要なすべての依存関係を含めてください。ESLintルールを抑制したり、エフェクトのコードが使用する依存関係を省略したりしないでください。エフェクトコールバックを構造化して、変化する値を適切に処理してください（例：prop変更時のサブスクリプションの更新、アンマウントまたは依存関係変更時のクリーンアップ）。ユーザーアクション（フォーム送信やボタンクリックなど）に応じてのみ実行されるべきロジックの場合は、そのロジックを`useEffect`ではなくイベントハンドラーに配置してください。可能な場合、`useEffect`はクリーンアップ関数を返すべきです。

フックのルールに従う: フック（`useState`、`useEffect`、`useContext`、カスタムフック等）がReact関数コンポーネントまたは他のフックのトップレベルで無条件に呼び出されることを確認してください。ループ、条件文、またはネストされたヘルパー関数内でフックを呼び出すコードを生成しないでください。非コンポーネント関数やReactコンポーネントレンダリングコンテキスト外でフックを呼び出さないでください。

必要な場合のみrefを使用: 本当に必要な場合（コントロールのフォーカス、アニメーションの管理、非Reactライブラリとの統合など）を除いて、`useRef`の使用を避けてください。リアクティブであるべきアプリケーション状態を格納するためにrefを使用しないでください。refを使用する場合は、コンポーネントのレンダリング中に`ref.current`に書き込んだり読み取ったりしないでください（遅延初期化などの初期設定を除く）。refの使用は、レンダリングされた出力に直接影響しないようにしてください。

コンポジションと小さなコンポーネントを優先: 大きなモノリシックコンポーネントを書くのではなく、UIを小さく再利用可能なコンポーネントに分解してください。生成するコードは、コンポーネントを組み合わせることで明確性と再利用性を促進する必要があります。同様に、コードの重複を避けるために、適切な場合は反復的なロジックをカスタムフックに抽象化してください。

並行性のために最適化: Reactがスケジューリング目的でコンポーネントを複数回レンダリングする可能性があることを想定してください（特に開発環境でStrict Modeを使用している場合）。コンポーネント関数が複数回実行されても正しく動作するコードを書いてください。例えば、コンポーネント本体で副作用を避け、前の状態に基づいて状態を更新する際は関数型状態更新（例：`setCount(c => c + 1)`）を使用して競合状態を防いでください。外部リソースをサブスクライブするエフェクトには常にクリーンアップ関数を含めてください。「これが変更されたときにこれを実行する」副作用のために`useEffect`を書かないでください。これにより、生成されたコードがReactの並行レンダリング機能と問題なく動作することが保証されます。

ネットワークウォーターフォールを削減するために最適化 - 可能な限り並列データフェッチを使用してください（例：順次ではなく複数のリクエストを同時に開始）。データローディングにSuspenseを活用し、データを必要とするコンポーネントと一緒にリクエストを配置してください。サーバー中心のアプローチでは、サーバー側で関連データを一緒にフェッチして（例：Server Componentsを使用）往復を削減してください。また、同一のリクエストの繰り返しを避けるために、キャッシュレイヤーやグローバルフェッチ管理の使用を検討してください。

React Compilerに依存 - React Compilerが有効な場合、`useMemo`、`useCallback`、`React.memo`は省略できます。手動メモ化による早期最適化を避けてください。代わりに、直接的なデータフローと副作用のないレンダリング関数を持つ明確でシンプルなコンポーネントの記述に焦点を当ててください。React Compilerにツリーシェイキング、インライン化、その他のパフォーマンス向上を処理させて、コードベースをよりシンプルで保守しやすく保ってください。

良いユーザーエクスペリエンスのために設計 - 明確で最小限の、ノンブロッキングなUI状態を提供してください。データがローディング中の場合は、どこでも侵入的なスピナーではなく、軽量なプレースホルダー（例：スケルトンスクリーン）を表示してください。専用のエラーバウンダリーまたは親しみやすいインラインメッセージでエラーを適切に処理してください。可能な場合は、すべてを待たせるのではなく、利用可能になった部分的なデータをレンダリングしてください。Suspenseを使用すると、コンポーネントツリーでローディング状態を自然な方法で宣言でき、「フラッシュ」状態を防ぎ、知覚されるパフォーマンスを向上させます。

### プロセス

1. ユーザーのコードを最適化の機会について分析:

   - コンパイラの最適化を妨げるReactアンチパターンをチェック
   - コンパイラの効果を制限するコンポーネント構造の問題を探す
   - 各提案について考え、ベストプラクティスについてReactドキュメントを参照

2. 実行可能なガイダンスを提供:
   - 明確な理由付きで具体的なコード変更を説明
   - 変更を提案する際は、変更前後の例を示す
   - 最適化の可能性を意味のある形で向上させる変更のみを提案

### 最適化ガイドライン

- 状態更新は、細かい更新を可能にするように構造化する必要があります
- 副作用は分離し、依存関係を明確に定義する必要があります

## コメントポリシー

高価値のコメントのみを書いてください。コメントを通じてユーザーと話すことは避けてください。 