# Gemini CLIでのMCPサーバー

このドキュメントでは、Gemini CLIでモデルコンテキストプロトコル（MCP）サーバーを構成して使用するためのガイドを提供します。

## MCPサーバーとは？

MCPサーバーは、モデルコンテキストプロトコルを通じてGemini CLIにツールとリソースを公開するアプリケーションであり、外部システムやデータソースと対話できるようにします。MCPサーバーは、Geminiモデルとローカル環境またはAPIなどの他のサービスとの間のブリッジとして機能します。

MCPサーバーを使用すると、Gemini CLIは次のことが可能になります。

- **ツールの検出:** 標準化されたスキーマ定義を通じて、利用可能なツール、その説明、およびパラメーターを一覧表示します。
- **ツールの実行:** 定義された引数で特定のツールを呼び出し、構造化された応答を受信します。
- **リソースへのアクセス:** 特定のリソースからデータを読み取ります（ただし、Gemini CLIは主にツールの実行に重点を置いています）。

MCPサーバーを使用すると、Gemini CLIの機能を拡張して、データベース、API、カスタムスクリプト、または特殊なワークフローとの対話など、組み込み機能を超えるアクションを実行できます。

## コア統合アーキテクチャ

Gemini CLIは、コアパッケージ（`packages/core/src/tools/`）に組み込まれた高度な検出および実行システムを介してMCPサーバーと統合します。

### 検出レイヤー（`mcp-client.ts`）

検出プロセスは`discoverMcpTools()`によって調整され、次の処理が行われます。

1.  **構成済みサーバーの反復処理:** `settings.json`の`mcpServers`構成から構成済みサーバーを反復処理します。
2.  **接続の確立:** 適切なトランスポートメカニズム（Stdio、SSE、またはストリーマブルHTTP）を使用して接続を確立します。
3.  **ツール定義の取得:** MCPプロトコルを使用して各サーバーからツール定義を取得します。
4.  **ツールスキーマのサニタイズと検証:** Gemini APIとの互換性のためにツールスキーマをサニタイズおよび検証します。
5.  **競合解決によるツールの登録:** グローバルツールレジストリにツールを登録し、競合を解決します。

### 実行レイヤー（`mcp-tool.ts`）

検出された各MCPツールは、次の処理を行う`DiscoveredMCPTool`インスタンスでラップされます。

- **確認ロジックの処理:** サーバーの信頼設定とユーザーの好みに基づいて確認ロジックを処理します。
- **ツール実行の管理:** 適切なパラメーターでMCPサーバーを呼び出してツール実行を管理します。
- **LLMコンテキストとユーザー表示の両方の応答の処理:** LLMコンテキストとユーザー表示の両方の応答を処理します。
- **接続状態の維持とタイムアウトの処理:** 接続状態を維持し、タイムアウトを処理します。

### トランスポートメカニズム

Gemini CLIは、次の3つのMCPトランスポートタイプをサポートしています。

- **Stdioトランスポート:** サブプロセスを生成し、標準入出力を介して通信します。
- **SSEトランスポート:** Server-Sent Eventsエンドポイントに接続します。
- **ストリーマブルHTTPトランスポート:** 通信にHTTPストリーミングを使用します。

## MCPサーバーの設定方法

Gemini CLIは、`settings.json`ファイルの`mcpServers`構成を使用して、MCPサーバーを検索して接続します。この構成は、さまざまなトランスポートメカニズムを持つ複数のサーバーをサポートします。

### settings.jsonでMCPサーバーを構成する

MCPサーバーは、`~/.gemini/settings.json`ファイルのグローバルレベルで構成するか、プロジェクトのルートディレクトリで`.gemini/settings.json`ファイルを作成または開きます。ファイル内に、`mcpServers`構成ブロックを追加します。

### 構成構造

`settings.json`ファイルに`mcpServers`オブジェクトを追加します。

```json
{ ...ファイルには他の構成オブジェクトが含まれています
  "mcpServers": {
    "serverName": {
      "command": "path/to/server",
      "args": ["--arg1", "value1"],
      "env": {
        "API_KEY": "$MY_API_TOKEN"
      },
      "cwd": "./server-directory",
      "timeout": 30000,
      "trust": false
    }
  }
}
```

### 構成プロパティ

各サーバー構成は、次のプロパティをサポートしています。

#### 必須（次のいずれか）

- **`command`**（文字列）: Stdioトランスポート用の実行可能ファイルへのパス
- **`url`**（文字列）: SSEエンドポイントURL（例：`"http://localhost:8080/sse"`）
- **`httpUrl`**（文字列）: HTTPストリーミングエンドポイントURL

#### オプション

- **`args`**（文字列配列）: Stdioトランスポートのコマンドライン引数
- **`env`**（オブジェクト）: サーバープロセスの環境変数。値は`$VAR_NAME`または`${VAR_NAME}`構文を使用して環境変数を参照できます。
- **`cwd`**（文字列）: Stdioトランスポートの作業ディレクトリ
- **`timeout`**（数値）: リクエストのタイムアウト（ミリ秒）（デフォルト：600,000ms = 10分）
- **`trust`**（ブール値）: `true`の場合、このサーバーのすべてのツール呼び出し確認をバイパスします（デフォルト：`false`）

### 構成例

#### Python MCPサーバー（Stdio）

```json
{
  "mcpServers": {
    "pythonTools": {
      "command": "python",
      "args": ["-m", "my_mcp_server", "--port", "8080"],
      "cwd": "./mcp-servers/python",
      "env": {
        "DATABASE_URL": "$DB_CONNECTION_STRING",
        "API_KEY": "${EXTERNAL_API_KEY}"
      },
      "timeout": 15000
    }
  }
}
```

#### Node.js MCPサーバー（Stdio）

```json
{
  "mcpServers": {
    "nodeServer": {
      "command": "node",
      "args": ["dist/server.js", "--verbose"],
      "cwd": "./mcp-servers/node",
      "trust": true
    }
  }
}
```

#### DockerベースのMCPサーバー

```json
{
  "mcpServers": {
    "dockerizedServer": {
      "command": "docker",
      "args": [
        "run",
        "-i",
        "--rm",
        "-e",
        "API_KEY",
        "-v",
        "${PWD}:/workspace",
        "my-mcp-server:latest"
      ],
      "env": {
        "API_KEY": "$EXTERNAL_SERVICE_TOKEN"
      }
    }
  }
}
```

#### HTTPベースのMCPサーバー

```json
{
  "mcpServers": {
    "httpServer": {
      "httpUrl": "http://localhost:3000/mcp",
      "timeout": 5000
    }
  }
}
```

## 検出プロセスの詳細

Gemini CLIが起動すると、次の詳細なプロセスを通じてMCPサーバーの検出が実行されます。

### 1. サーバーの反復処理と接続

`mcpServers`で構成されている各サーバーについて：

1.  **ステータス追跡の開始:** サーバーステータスが`CONNECTING`に設定されます。
2.  **トランスポートの選択:** 構成プロパティに基づいて：
    - `httpUrl` → `StreamableHTTPClientTransport`
    - `url` → `SSEClientTransport`
    - `command` → `StdioClientTransport`
3.  **接続の確立:** MCPクライアントは、構成されたタイムアウトで接続を試みます。
4.  **エラー処理:** 接続の失敗はログに記録され、サーバーステータスは`DISCONNECTED`に設定されます。

### 2. ツールの検出

接続に成功すると：

1.  **ツールのリスト表示:** クライアントはMCPサーバーのツールリスト表示エンドポイントを呼び出します。
2.  **スキーマの検証:** 各ツールの関数宣言が検証されます。
3.  **名前のサニタイズ:** Gemini APIの要件を満たすようにツール名がクリーンアップされます。
    - 無効な文字（英数字、アンダースコア、ドット、ハイフン以外）はアンダースコアに置き換えられます。
    - 63文字を超える名前は、中央を置き換えて切り詰められます（`___`）。

### 3. 競合の解決

複数のサーバーが同じ名前のツールを公開する場合：

1.  **最初の登録が優先:** ツール名を最初に登録したサーバーが、プレフィックスなしの名前を取得します。
2.  **自動プレフィックス:** 後続のサーバーはプレフィックス付きの名前を取得します：`serverName__toolName`
3.  **レジストリの追跡:** ツールレジストリは、サーバー名とそのツール間のマッピングを維持します。

### 4. スキーマの処理

ツールパラメータースキーマは、Gemini APIの互換性のためにサニタイズされます。

- **`$schema`プロパティ**は削除されます。
- **`additionalProperties`**は削除されます。
- **`default`を持つ`anyOf`**のデフォルト値は削除されます（Vertex AIの互換性）。
- **再帰的処理**は、ネストされたスキーマに適用されます。

### 5. 接続管理

検出後：

- **永続的な接続:** ツールを正常に登録したサーバーは、接続を維持します。
- **クリーンアップ:** 使用可能なツールを提供しないサーバーへの接続は、自動的に閉じられます。
- **ステータスの更新:** 最終的なサーバーステータスは`CONNECTED`または`DISCONNECTED`に設定されます。

## ツール実行フロー

GeminiモデルがMCPツールの使用を決定すると、次の実行フローが発生します。

### 1. ツールの呼び出し

モデルは、次のものを含む`FunctionCall`を生成します。

- **ツール名:** 登録された名前（プレフィックスが付加されている可能性があります）
- **引数:** ツールのパラメータースキーマに一致するJSONオブジェクト

### 2. 確認プロセス

各`DiscoveredMCPTool`は、高度な確認ロジックを実装しています。

#### 信頼ベースのバイパス

```typescript
if (this.trust) {
  return false; // 確認は不要
}
```

#### 動的許可リスト

システムは、次の内部許可リストを維持します。

- **サーバーレベル:** `serverName` → このサーバーのすべてのツールが信頼されます。
- **ツールレベル:** `serverName.toolName` → この特定のツールが信頼されます。

#### ユーザーの選択処理

確認が必要な場合、ユーザーは次のいずれかを選択できます。

- **一度だけ続行:** 今回のみ実行します。
- **このツールを常に許可:** ツールレベルの許可リストに追加します。
- **このサーバーを常に許可:** サーバーレベルの許可リストに追加します。
- **キャンセル:** 実行を中止します。

### 3. 実行

確認（または信頼によるバイパス）後：

1.  **パラメーターの準備:** 引数がツールのスキーマに対して検証されます。
2.  **MCP呼び出し:** 基盤となる`CallableTool`が、次のものを使用してサーバーを呼び出します。

    ```typescript
    const functionCalls = [
      {
        name: this.serverToolName, // 元のサーバーツール名
        args: params,
      },
    ];
    ```

3.  **応答の処理:** 結果は、LLMコンテキストとユーザー表示の両方のためにフォーマットされます。

### 4. 応答の処理

実行結果には次のものが含まれます。

- **`llmContent`:** 言語モデルのコンテキスト用の生の応答部分
- **`returnDisplay`:** ユーザー表示用にフォーマットされた出力（多くの場合、Markdownコードブロック内のJSON）

## MCPサーバーとの対話方法

### `/mcp`コマンドの使用

`/mcp`コマンドは、MCPサーバーの設定に関する包括的な情報を提供します。

```bash
/mcp
```

これにより、次のものが表示されます。

- **サーバーリスト:** 構成されているすべてのMCPサーバー
- **接続ステータス:** `CONNECTED`、`CONNECTING`、または`DISCONNECTED`
- **サーバーの詳細:** 構成の概要（機密データを除く）
- **利用可能なツール:** 各サーバーからのツールのリストと説明
- **検出状態:** 全体的な検出プロセスのステータス

### `/mcp`出力例

```
MCPサーバーのステータス：

📡 pythonTools（接続済み）
  コマンド：python -m my_mcp_server --port 8080
  作業ディレクトリ：./mcp-servers/python
  タイムアウト：15000ms
  ツール：calculate_sum、file_analyzer、data_processor

🔌 nodeServer（切断済み）
  コマンド：node dist/server.js --verbose
  エラー：接続が拒否されました

🐳 dockerizedServer（接続済み）
  コマンド：docker run -i --rm -e API_KEY my-mcp-server:latest
  ツール：docker__deploy、docker__status

検出状態：完了
```

### ツールの使用

検出されると、MCPツールは組み込みツールのようにGeminiモデルで利用可能になります。モデルは自動的に次のことを行います。

1.  **リクエストに基づいて適切なツールを選択**します。
2.  **確認ダイアログを表示**します（サーバーが信頼されていない場合）。
3.  **適切なパラメーターでツールを実行**します。
4.  **ユーザーフレンドリーな形式で結果を表示**します。

## ステータスの監視とトラブルシューティング

### 接続状態

MCP統合は、いくつかの状態を追跡します。

#### サーバーステータス（`MCPServerStatus`）

- **`DISCONNECTED`:** サーバーが接続されていないか、エラーがあります。
- **`CONNECTING`:** 接続試行中です。
- **`CONNECTED`:** サーバーが接続され、準備ができています。

#### 検出状態（`MCPDiscoveryState`）

- **`NOT_STARTED`:** 検出が開始されていません。
- **`IN_PROGRESS`:** 現在サーバーを検出中です。
- **`COMPLETED`:** 検出が完了しました（エラーの有無にかかわらず）。

### 一般的な問題と解決策

#### サーバーが接続されない

**症状:** サーバーステータスが`DISCONNECTED`と表示される

**トラブルシューティング:**

1.  **構成の確認:** `command`、`args`、`cwd`が正しいことを確認します。
2.  **手動でテスト:** サーバーコマンドを直接実行して、動作することを確認します。
3.  **依存関係の確認:** 必要なパッケージがすべてインストールされていることを確認します。
4.  **ログの確認:** CLI出力でエラーメッセージを探します。
5.  **権限の確認:** CLIがサーバーコマンドを実行できることを確認します。

#### ツールが検出されない

**症状:** サーバーは接続されますが、利用可能なツールがありません

**トラブルシューティング:**

1.  **ツールの登録の確認:** サーバーが実際にツールを登録していることを確認します。
2.  **MCPプロトコルの確認:** サーバーがMCPツールリスト表示を正しく実装していることを確認します。
3.  **サーバーログの確認:** サーバー側のエラーについては、stderr出力を確認します。
4.  **ツールリスト表示のテスト:** サーバーのツール検出エンドポイントを手動でテストします。

#### ツールが実行されない

**症状:** ツールは検出されますが、実行中に失敗します

**トラブルシューティング:**

1.  **パラメーターの検証:** ツールが期待されるパラメーターを受け入れることを確認します。
2.  **スキーマの互換性:** 入力スキーマが有効なJSONスキーマであることを確認します。
3.  **エラー処理:** ツールが未処理の例外をスローしていないか確認します。
4.  **タイムアウトの問題:** `timeout`設定を増やすことを検討します。

#### サンドボックスの互換性

**症状:** サンドボックスが有効になっているとMCPサーバーが失敗する

**解決策:**

1.  **Dockerベースのサーバー:** すべての依存関係を含むDockerコンテナーを使用します。
2.  **パスのアクセシビリティ:** サーバー実行可能ファイルがサンドボックスで利用可能であることを確認します。
3.  **ネットワークアクセス:** 必要なネットワーク接続を許可するようにサンドボックスを構成します。
4.  **環境変数:** 必要な環境変数が渡されていることを確認します。

### デバッグのヒント

1.  **デバッグモードの有効化:** CLIを`--debug_mode`で実行して、詳細な出力を取得します。
2.  **stderrの確認:** MCPサーバーのstderrがキャプチャされ、ログに記録されます（INFOメッセージはフィルター処理されます）。
3.  **分離テスト:** 統合する前に、MCPサーバーを個別にテストします。
4.  **段階的なセットアップ:** 複雑な機能を追加する前に、単純なツールから始めます。
5.  **`/mcp`を頻繁に使用:** 開発中にサーバーステータスを監視します。

## 重要事項

### セキュリティに関する考慮事項

- **信頼設定:** `trust`オプションは、すべての確認ダイアログをバイパスします。完全に制御しているサーバーに対してのみ、慎重に使用してください。
- **アクセストークン:** APIキーまたはトークンを含む環境変数を構成する場合は、セキュリティに注意してください。
- **サンドボックスの互換性:** サンドボックスを使用する場合は、MCPサーバーがサンドボックス環境内で利用可能であることを確認してください。
- **個人データ:** 広範囲のスコープを持つパーソナルアクセストークンを使用すると、リポジトリ間で情報が漏洩する可能性があります。

### パフォーマンスとリソース管理

- **接続の永続性:** CLIは、ツールを正常に登録したサーバーへの永続的な接続を維持します。
- **自動クリーンアップ:** ツールを提供しないサーバーへの接続は、自動的に閉じられます。
- **タイムアウト管理:** サーバーの応答特性に基づいて、適切なタイムアウトを構成します。
- **リソース監視:** MCPサーバーは別のプロセスとして実行され、システムリソースを消費します。

### スキーマの互換性

- **プロパティの削除:** システムは、Gemini APIの互換性のために、特定のスキーマプロパティ（`$schema`、`additionalProperties`）を自動的に削除します。
- **名前のサニタイズ:** API要件を満たすようにツール名が自動的にサニタイズされます。
- **競合の解決:** サーバー間のツール名の競合は、自動プレフィックスによって解決されます。

この包括的な統合により、MCPサーバーは、セキュリティ、信頼性、使いやすさを維持しながら、Gemini CLIの機能を拡張するための強力な方法になります。 